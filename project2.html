<!--Name: Iqra Rana, Date: 4/10/2018-->
<!DOCTYPE html>
<html>

<head>
	<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
	<title>Viewing and Lighting</title>

	<script id="vertex-shader" type="x-shader/x-vertex">

				// INSERT CODE HERE
				// Step 3.2: Lighting Calculations in Vertex Shader
				precision mediump float;
				attribute vec4 vertexPosition;
				attribute vec3 vertexNormal;
				
				// Set up uniforms for modelview, modelview inverse transpose, and projections
				uniform mat4 M;
				uniform mat4 M_inv_transpose;
				uniform mat4 projection_persp;			
				
				// Set up uniforms for the ambient, diffuse, and specular coefficients
				// of the object, and the shininess
				uniform vec3 ambient, diffuse, specular;
				uniform float shininess;
				
				mat4 trans;
				mat4 rot_y;
				
				// Set up uniforms for the first light source (uniforms depend on light source type,
				// at the very least, you need ambient, diffuse, and specular components,
				// but you may also need other variables such as position for point light,
				// direction for directional light, and/or position, direction of principal axis,
				// and exponent for spotlight
				uniform vec3 lightPosition1, lightAmbient1, lightDiffuse1, lightSpecular1;
				
				
				// Set up uniforms for the second light source
				uniform vec3 lightPosition2, lightAmbient2, lightDiffuse2, lightSpecular2;
				
				// Set up uniforms for switching on / off each light source
				uniform bool light1, light2;

				// If you are doing Gouraud shading, you will require a varying variable
				// for the final light intensity (and you can disregard the comment below)
				// As a note: Gouraud shading is much easier, but Phong shading is
				// more realistic
				varying vec3 R;
				
				
				// If you are doing Phong shading, you will need varying variables for
				// the light components when they come to the vertex position (for point
				// and spot light, the light gets attenuated),
				// and varying variables to interpolate the vector against the incident direction (i), the
				// view vector (view), and the normal vector (n)
				// (If you are doing Phong, disregard the comment above)
				
				void main() {
					gl_PointSize = 1.0;
					
					
					// Part 3.2: calculations in main function ---
					
					// Transform the vertex by the modelview matrix for future lighting calculations
					vec3 pos = (M * vertexPosition).xyz;
					
					
					// Transform the normal by the inverse transpose of modelview matrix
					// for future lighting calculations
					vec4 vertexNormal4 = vec4(vertexNormal.x, vertexNormal.y, vertexNormal.z, 1.0);
					vec3 pos1 = (M_inv_transpose * vertexNormal4).xyz;
					
					
					// For first light source, compute how much light comes to the vertex by using the
					// appropriate equation for that light source. By the way, if you are using
					// a point or spot light source, you will find that it is better to soften the
					// denominator using the form ad^2 + bd + c
					//attenuated light components
					vec3 Ia_pp0, Id_pp0, Is_pp0;
					float distance = length(vertexPosition.xyz - lightPosition1);
					
					Ia_pp0 = lightAmbient1 / (distance*distance);
					Id_pp0 = lightDiffuse1 / (distance*distance);
					Is_pp0 = lightSpecular1 / (distance*distance);
					
					
					// For the second light source, compute how much light comes to the vertex
					// by using the appropriate equation for that light source
					vec3 Ia_pp02, Id_pp02, Is_pp02;
					float distance2 = length(vertexPosition.xyz - lightPosition2);
					
					Ia_pp02 = lightAmbient2 / (distance2*distance2);
					Id_pp02 = lightDiffuse2 / (distance2*distance2);
					Is_pp02 = lightSpecular2 / (distance2*distance2);
					
					
					
					// Compute the vector 'i' against the direction of incidence
					// USING THE TRANSFORMED VERTEX POSITION (not the original vertex position!)
					vec3 i1 = normalize(lightPosition1 - pos.xyz);
					
					float costheta1 = dot(i1, pos1);
					
					// Compute the vector 'view' for the direction of the viewer
					vec3 r1 = normalize(2.0 * costheta1 * pos1.xyz - i1);
					vec3 view = normalize(vec3(0.0, 0.0, 0.0) - pos.xyz);
					
					
					// If you are doing Phong shading, disregard the lines between
					// "Start of Gouraud shading" to "End of Gouraud shading" and move
					// on to the fragment shader AFTER ENSURING THAT THE VARYING VARIABLES
					// FOR the lighting components, i, view, AND n ARE CORRECTLY SET UP.
					// You may find it handy to zero out lighting components
					// corresponding to switched out lights before going to the
					// fragment shader for Phong shading.
					
					
					// *** Start of Gouraud shading ***
					
					// Compute the ambient reflection for the first light source
					vec3 Ra1, Rd1, Rs1;
					
					//AmbientReflection
					if(light1){
						Ra1.r = ambient.r * Ia_pp0.r;
						Ra1.g = ambient.g * Ia_pp0.g;
						Ra1.b = ambient.b * Ia_pp0.b;
					}
					else{
						Ra1.r = 0.0;
						Ra1.g = 0.0;
						Ra1.b = 0.0;
					}
					
					// Compute the diffuse reflection for the first light source
					// USING THE TRANSFORMED NORMAL
					if(light1){
						Rd1.r = diffuse.r * Id_pp0.r * max(costheta1, 0.0);
						Rd1.g = diffuse.g * Id_pp0.g * max(costheta1, 0.0);
						Rd1.b = diffuse.b * Id_pp0.b * max(costheta1, 0.0);
					}
					else{
						Rd1.r = 0.0;
						Rd1.g = 0.0;
						Rd1.b = 0.0;
					}
					
					
					// Compute the specular reflection for the first light source
					// AGAIN USING THE TRANSFORMED NORMAL
					float cosphi1 = dot(r1, view);
					float shine = pow(max(cosphi1, 0.0), shininess);
					float costhetag01 = floor(0.5 * (sign(costheta1)+1.0));
					
					if(light1){
						Rs1.r = specular.r * Is_pp0.r * shine * costhetag01;
						Rs1.g = specular.g * Is_pp0.g * shine * costhetag01;
						Rs1.b = specular.b * Is_pp0.b * shine * costhetag01;
					}
					else{
						Rs1.r = 0.0;
						Rs1.g = 0.0;
						Rs1.b = 0.0;
					}
					
					
					// Compute the ambient reflection for the second light source
					vec3 i2 = normalize(lightPosition2 - pos.xyz);
					float costheta2 = dot(i2, pos1);					
					vec3 r2 = normalize(2.0 * costheta2 * pos1.xyz - i2);
					
					vec3 Ra2, Rd2, Rs2;
					
					if(light2){
						Ra2.r = ambient.r * Ia_pp02.r;
						Ra2.g = ambient.g * Ia_pp02.g;
						Ra2.b = ambient.b * Ia_pp02.b;
					}					
					else{
						Ra2.r = 0.0;
						Ra2.g = 0.0;
						Ra2.b = 0.0;
					}
					
					
					// Compute the diffuse reflection for the second light source
					// USING THE TRANSFORMED NORMAL
					if(light2){
						Rd2.r = diffuse.r * Id_pp02.r * max(costheta2, 0.0);
						Rd2.g = diffuse.g * Id_pp02.g * max(costheta2, 0.0);
						Rd2.b = diffuse.b * Id_pp02.b * max(costheta2, 0.0);
					}
					else{
						Rd2.r = 0.0;
						Rd2.g = 0.0;
						Rd2.b = 0.0;
					}
					
					// Compute the specular reflection for the second light source
					// AGAIN USING THE TRANSFORMED NORMAL
					float cosphi2 = dot(r2, view);
					float shine2 = pow(max(cosphi2, 0.0), shininess);
					float costhetag02 = floor(0.5 * (sign(costheta2)+1.0));
					
					if(light2){
						Rs2.r = specular.r * Is_pp02.r * shine2 * costhetag02;
						Rs2.g = specular.g * Is_pp02.g * shine2 * costhetag02;
						Rs2.b = specular.b * Is_pp02.b * shine2 * costhetag02;
					}
					else{
						Rs2.r = 0.0;
						Rs2.g = 0.0;
						Rs2.b = 0.0;
					}
					
					// Calculate the total reflected light by summing
					// the ambient, diffuse, and specular reflections for
					// all lights that are *on*. This reflected light
					// should be assigned to the varying variable for the
					// final light intensity
					R = clamp(Ra1+Rd1+Rs1 + Ra2+Rd2+Rs2, 0.0, 1.0);
					
					
					// *** End of Gouraud shading ***
					 
					trans = mat4 
					(1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					-100, 0, 0, 1);
					
					rot_y = mat4 
					(cos(-5.0), 0, -sin(-5.0), 0,
					 0, 1, 0, 0,
					 sin(-5.0), 0, cos(-5.0), 0,
					 0, 0, 0, 1);
					
					// EVEN IF YOU ARE NOT WORKING ON THE SECOND ITERATION,
					// YOU MUST APPLY THE MODEL VIEW AND PROJECTION
					// MATRICES TO vertexPosition TO GET gl_Position!*/
					gl_Position = projection_persp * M * trans * rot_y * vertexPosition; 
				}

		</script>

	<script id="vertex-shaderChair2" type="x-shader/x-vertex">

				// INSERT CODE HERE
				// Step 3.2: Lighting Calculations in Vertex Shader
				precision mediump float;
				attribute vec4 vertexPosition;
				attribute vec3 vertexNormal;
				
				// Set up uniforms for modelview, modelview inverse transpose, and projections
				uniform mat4 M;
				uniform mat4 M_inv_transpose;
				uniform mat4 projection_persp;				
				
				// Set up uniforms for the ambient, diffuse, and specular coefficients
				// of the object, and the shininess
				uniform vec3 ambient, diffuse, specular;
				uniform float shininess;
				
				mat4 trans;
				mat4 rot_y;
				
				// Set up uniforms for the first light source (uniforms depend on light source type,
				// at the very least, you need ambient, diffuse, and specular components,
				// but you may also need other variables such as position for point light,
				// direction for directional light, and/or position, direction of principal axis,
				// and exponent for spotlight
				uniform vec3 lightPosition1, lightAmbient1, lightDiffuse1, lightSpecular1;
				
				
				// Set up uniforms for the second light source
				uniform vec3 lightPosition2, lightAmbient2, lightDiffuse2, lightSpecular2;
				
				// Set up uniforms for switching on / off each light source
				uniform bool light1, light2;

				// If you are doing Gouraud shading, you will require a varying variable
				// for the final light intensity (and you can disregard the comment below)
				// As a note: Gouraud shading is much easier, but Phong shading is
				// more realistic
				varying vec3 R;
				
				
				// If you are doing Phong shading, you will need varying variables for
				// the light components when they come to the vertex position (for point
				// and spot light, the light gets attenuated),
				// and varying variables to interpolate the vector against the incident direction (i), the
				// view vector (view), and the normal vector (n)
				// (If you are doing Phong, disregard the comment above)
				
				void main() {
					gl_PointSize = 1.0;
					
					
					// Part 3.2: calculations in main function ---
					
					// Transform the vertex by the modelview matrix for future lighting calculations
					vec3 pos = (M * vertexPosition).xyz;
					
					
					// Transform the normal by the inverse transpose of modelview matrix
					// for future lighting calculations
					vec4 vertexNormal4 = vec4(vertexNormal.x, vertexNormal.y, vertexNormal.z, 1.0);
					vec3 pos1 = (M_inv_transpose * vertexNormal4).xyz;
					
					
					// For first light source, compute how much light comes to the vertex by using the
					// appropriate equation for that light source. By the way, if you are using
					// a point or spot light source, you will find that it is better to soften the
					// denominator using the form ad^2 + bd + c
					//attenuated light components
					vec3 Ia_pp0, Id_pp0, Is_pp0;
					float distance = length(vertexPosition.xyz - lightPosition1);
					
					Ia_pp0 = lightAmbient1 / (distance*distance);
					Id_pp0 = lightDiffuse1 / (distance*distance);
					Is_pp0 = lightSpecular1 / (distance*distance);
					
					
					// For the second light source, compute how much light comes to the vertex
					// by using the appropriate equation for that light source
					vec3 Ia_pp02, Id_pp02, Is_pp02;
					float distance2 = length(vertexPosition.xyz - lightPosition2);
					
					Ia_pp02 = lightAmbient2 / (distance2*distance2);
					Id_pp02 = lightDiffuse2 / (distance2*distance2);
					Is_pp02 = lightSpecular2 / (distance2*distance2);
					
					
					
					// Compute the vector 'i' against the direction of incidence
					// USING THE TRANSFORMED VERTEX POSITION (not the original vertex position!)
					vec3 i1 = normalize(lightPosition1 - pos.xyz);
					
					float costheta1 = dot(i1, pos1);
					
					// Compute the vector 'view' for the direction of the viewer
					vec3 r1 = normalize(2.0 * costheta1 * pos1.xyz - i1);
					vec3 view = normalize(vec3(0.0, 0.0, 0.0) - pos.xyz);
					
					
					// If you are doing Phong shading, disregard the lines between
					// "Start of Gouraud shading" to "End of Gouraud shading" and move
					// on to the fragment shader AFTER ENSURING THAT THE VARYING VARIABLES
					// FOR the lighting components, i, view, AND n ARE CORRECTLY SET UP.
					// You may find it handy to zero out lighting components
					// corresponding to switched out lights before going to the
					// fragment shader for Phong shading.
					
					
					// *** Start of Gouraud shading ***
					
					// Compute the ambient reflection for the first light source
					vec3 Ra1, Rd1, Rs1;
					
					//AmbientReflection
					if(light1){
						Ra1.r = ambient.r * Ia_pp0.r;
						Ra1.g = ambient.g * Ia_pp0.g;
						Ra1.b = ambient.b * Ia_pp0.b;
					}
					else{
						Ra1.r = 0.0;
						Ra1.g = 0.0;
						Ra1.b = 0.0;
					}
					
					// Compute the diffuse reflection for the first light source
					// USING THE TRANSFORMED NORMAL
					if(light1){
						Rd1.r = diffuse.r * Id_pp0.r * max(costheta1, 0.0);
						Rd1.g = diffuse.g * Id_pp0.g * max(costheta1, 0.0);
						Rd1.b = diffuse.b * Id_pp0.b * max(costheta1, 0.0);
					}
					else{
						Rd1.r = 0.0;
						Rd1.g = 0.0;
						Rd1.b = 0.0;
					}
					
					
					// Compute the specular reflection for the first light source
					// AGAIN USING THE TRANSFORMED NORMAL
					float cosphi1 = dot(r1, view);
					float shine = pow(max(cosphi1, 0.0), shininess);
					float costhetag01 = floor(0.5 * (sign(costheta1)+1.0));
					
					if(light1){
						Rs1.r = specular.r * Is_pp0.r * shine * costhetag01;
						Rs1.g = specular.g * Is_pp0.g * shine * costhetag01;
						Rs1.b = specular.b * Is_pp0.b * shine * costhetag01;
					}
					else{
						Rs1.r = 0.0;
						Rs1.g = 0.0;
						Rs1.b = 0.0;
					}
					
					
					// Compute the ambient reflection for the second light source
					vec3 i2 = normalize(lightPosition2 - pos.xyz);
					float costheta2 = dot(i2, pos1);					
					vec3 r2 = normalize(2.0 * costheta2 * pos1.xyz - i2);
					
					vec3 Ra2, Rd2, Rs2;
					
					if(light2){
						Ra2.r = ambient.r * Ia_pp02.r;
						Ra2.g = ambient.g * Ia_pp02.g;
						Ra2.b = ambient.b * Ia_pp02.b;
					}					
					else{
						Ra2.r = 0.0;
						Ra2.g = 0.0;
						Ra2.b = 0.0;
					}
					
					
					// Compute the diffuse reflection for the second light source
					// USING THE TRANSFORMED NORMAL
					if(light2){
						Rd2.r = diffuse.r * Id_pp02.r * max(costheta2, 0.0);
						Rd2.g = diffuse.g * Id_pp02.g * max(costheta2, 0.0);
						Rd2.b = diffuse.b * Id_pp02.b * max(costheta2, 0.0);
					}
					else{
						Rd2.r = 0.0;
						Rd2.g = 0.0;
						Rd2.b = 0.0;
					}
					
					// Compute the specular reflection for the second light source
					// AGAIN USING THE TRANSFORMED NORMAL
					float cosphi2 = dot(r2, view);
					float shine2 = pow(max(cosphi2, 0.0), shininess);
					float costhetag02 = floor(0.5 * (sign(costheta2)+1.0));
					
					if(light2){
						Rs2.r = specular.r * Is_pp02.r * shine2 * costhetag02;
						Rs2.g = specular.g * Is_pp02.g * shine2 * costhetag02;
						Rs2.b = specular.b * Is_pp02.b * shine2 * costhetag02;
					}
					else{
						Rs2.r = 0.0;
						Rs2.g = 0.0;
						Rs2.b = 0.0;
					}
					
					// Calculate the total reflected light by summing
					// the ambient, diffuse, and specular reflections for
					// all lights that are *on*. This reflected light
					// should be assigned to the varying variable for the
					// final light intensity
					R = clamp(Ra1+Rd1+Rs1 + Ra2+Rd2+Rs2, 0.0, 1.0);
					
					
					// *** End of Gouraud shading ***
					
					trans = mat4
					(1, 0, 0, 0,
					 0, 1, 0, 0,
					 0, 0, 1, 0,
					 70, 0, -30, 1);
					
					rot_y = mat4 
					(cos(-0.5), 0, -sin(-0.5), 0,
					 0, 1, 0, 0,
					 sin(-0.5), 0, cos(-0.5), 0,
					 0, 0, 0, 1);
					
					// EVEN IF YOU ARE NOT WORKING ON THE SECOND ITERATION,
					// YOU MUST APPLY THE MODEL VIEW AND PROJECTION
					// MATRICES TO vertexPosition TO GET gl_Position!*/
					gl_Position = projection_persp * M * trans * rot_y * vertexPosition; 
				}

		</script>
		
		<script id="vertex-shaderTable" type="x-shader/x-vertex">

				// INSERT CODE HERE
				// Step 3.2: Lighting Calculations in Vertex Shader
				precision mediump float;
				attribute vec4 vertexPosition;
				attribute vec3 vertexNormal;
				attribute vec4 vertexColor;
				varying vec4 fragmentColor;
				
				// Set up uniforms for modelview, modelview inverse transpose, and projections
				uniform mat4 M;
				uniform mat4 M_inv_transpose;
				uniform mat4 projection_persp;				
				
				// Set up uniforms for the ambient, diffuse, and specular coefficients
				// of the object, and the shininess
				uniform vec3 ambient, diffuse, specular;
				uniform float shininess;
				
				mat4 trans;
				mat4 rot_y;
				
				// Set up uniforms for the first light source (uniforms depend on light source type,
				uniform vec3 lightPosition1, lightAmbient1, lightDiffuse1, lightSpecular1;
				
				
				// Set up uniforms for the second light source
				uniform vec3 lightPosition2, lightAmbient2, lightDiffuse2, lightSpecular2;
				
				// Set up uniforms for switching on / off each light source
				uniform bool light1, light2;

				// If you are doing Gouraud shading, you will require a varying variable
				// for the final light intensity (and you can disregard the comment below)
				// As a note: Gouraud shading is much easier, but Phong shading is
				// more realistic
				varying vec3 R;
				
				
				// If you are doing Phong shading, you will need varying variables for
				// the light components when they come to the vertex position (for point
				// and spot light, the light gets attenuated),
				// and varying variables to interpolate the vector against the incident direction (i), the
				// view vector (view), and the normal vector (n)
				// (If you are doing Phong, disregard the comment above)
				
				void main() {
					gl_PointSize = 1.0;
					
					// Transform the vertex by the modelview matrix for future lighting calculations
					vec3 pos = (M * vertexPosition).xyz;
					
					
					// Transform the normal by the inverse transpose of modelview matrix
					// for future lighting calculations
					vec4 vertexNormal4 = vec4(vertexNormal.x, vertexNormal.y, vertexNormal.z, 1.0);
					vec3 pos1 = (M_inv_transpose * vertexNormal4).xyz;
					
					
					// For first light source, compute how much light comes to the vertex by using the
					// appropriate equation for that light source. By the way, if you are using
					// a point or spot light source, you will find that it is better to soften the
					// denominator using the form ad^2 + bd + c
					//attenuated light components
					vec3 Ia_pp0, Id_pp0, Is_pp0;
					float distance = length(vertexPosition.xyz - lightPosition1);
					
					Ia_pp0 = lightAmbient1 / (distance*distance);
					Id_pp0 = lightDiffuse1 / (distance*distance);
					Is_pp0 = lightSpecular1 / (distance*distance);
					
					
					// For the second light source, compute how much light comes to the vertex
					// by using the appropriate equation for that light source
					vec3 Ia_pp02, Id_pp02, Is_pp02;
					float distance2 = length(vertexPosition.xyz - lightPosition2);
					
					Ia_pp02 = lightAmbient2 / (distance2*distance2);
					Id_pp02 = lightDiffuse2 / (distance2*distance2);
					Is_pp02 = lightSpecular2 / (distance2*distance2);
					
					
					
					// Compute the vector 'i' against the direction of incidence
					// USING THE TRANSFORMED VERTEX POSITION (not the original vertex position!)
					vec3 i1 = normalize(lightPosition1 - pos.xyz);
					
					float costheta1 = dot(i1, pos1);
					
					// Compute the vector 'view' for the direction of the viewer
					vec3 r1 = normalize(2.0 * costheta1 * pos1.xyz - i1);
					vec3 view = normalize(vec3(0.0, 0.0, 0.0) - pos.xyz);
					
					
					// If you are doing Phong shading, disregard the lines between
					// "Start of Gouraud shading" to "End of Gouraud shading" and move
					// on to the fragment shader AFTER ENSURING THAT THE VARYING VARIABLES
					// FOR the lighting components, i, view, AND n ARE CORRECTLY SET UP.
					// You may find it handy to zero out lighting components
					// corresponding to switched out lights before going to the
					// fragment shader for Phong shading.
					
					
					// *** Start of Gouraud shading ***
					
					// Compute the ambient reflection for the first light source
					vec3 Ra1, Rd1, Rs1;
					
					//AmbientReflection
					if(light1){
						Ra1.r = ambient.r * Ia_pp0.r;
						Ra1.g = ambient.g * Ia_pp0.g;
						Ra1.b = ambient.b * Ia_pp0.b;
					}
					else{
						Ra1.r = 0.0;
						Ra1.g = 0.0;
						Ra1.b = 0.0;
					}
					
					// Compute the diffuse reflection for the first light source
					// USING THE TRANSFORMED NORMAL
					if(light1){
						Rd1.r = diffuse.r * Id_pp0.r * max(costheta1, 0.0);
						Rd1.g = diffuse.g * Id_pp0.g * max(costheta1, 0.0);
						Rd1.b = diffuse.b * Id_pp0.b * max(costheta1, 0.0);
					}
					else{
						Rd1.r = 0.0;
						Rd1.g = 0.0;
						Rd1.b = 0.0;
					}
					
					
					// Compute the specular reflection for the first light source
					// AGAIN USING THE TRANSFORMED NORMAL
					float cosphi1 = dot(r1, view);
					float shine = pow(max(cosphi1, 0.0), shininess);
					float costhetag01 = floor(0.5 * (sign(costheta1)+1.0));
					
					if(light1){
						Rs1.r = specular.r * Is_pp0.r * shine * costhetag01;
						Rs1.g = specular.g * Is_pp0.g * shine * costhetag01;
						Rs1.b = specular.b * Is_pp0.b * shine * costhetag01;
					}
					else{
						Rs1.r = 0.0;
						Rs1.g = 0.0;
						Rs1.b = 0.0;
					}
					
					
					// Compute the ambient reflection for the second light source
					vec3 i2 = normalize(lightPosition2 - pos.xyz);
					float costheta2 = dot(i2, pos1);					
					vec3 r2 = normalize(2.0 * costheta2 * pos1.xyz - i2);
					
					vec3 Ra2, Rd2, Rs2;
					
					if(light2){
						Ra2.r = ambient.r * Ia_pp02.r;
						Ra2.g = ambient.g * Ia_pp02.g;
						Ra2.b = ambient.b * Ia_pp02.b;
					}					
					else{
						Ra2.r = 0.0;
						Ra2.g = 0.0;
						Ra2.b = 0.0;
					}
					
					
					// Compute the diffuse reflection for the second light source
					// USING THE TRANSFORMED NORMAL
					if(light2){
						Rd2.r = diffuse.r * Id_pp02.r * max(costheta2, 0.0);
						Rd2.g = diffuse.g * Id_pp02.g * max(costheta2, 0.0);
						Rd2.b = diffuse.b * Id_pp02.b * max(costheta2, 0.0);
					}
					else{
						Rd2.r = 0.0;
						Rd2.g = 0.0;
						Rd2.b = 0.0;
					}
					
					// Compute the specular reflection for the second light source
					// AGAIN USING THE TRANSFORMED NORMAL
					float cosphi2 = dot(r2, view);
					float shine2 = pow(max(cosphi2, 0.0), shininess);
					float costhetag02 = floor(0.5 * (sign(costheta2)+1.0));
					
					if(light2){
						Rs2.r = specular.r * Is_pp02.r * shine2 * costhetag02;
						Rs2.g = specular.g * Is_pp02.g * shine2 * costhetag02;
						Rs2.b = specular.b * Is_pp02.b * shine2 * costhetag02;
					}
					else{
						Rs2.r = 0.0;
						Rs2.g = 0.0;
						Rs2.b = 0.0;
					}
					
					// Calculate the total reflected light by summing
					// the ambient, diffuse, and specular reflections for
					// all lights that are *on*. This reflected light
					// should be assigned to the varying variable for the
					// final light intensity
					R = clamp(Ra1+Rd1+Rs1 + Ra2+Rd2+Rs2, 0.0, 1.0);
					
					
					// *** End of Gouraud shading ***
					
					trans = mat4
					(1, 0, 0, 0,
					 0, 1, 0, 0,
					 0, 0, 1, 0,
					 -10, 0, -30, 1);
					/*
					rot_y = mat4 
					(cos(5.0), 0, -sin(5.0), 0,
					 0, 1, 0, 0,
					 sin(5.0), 0, cos(5.0), 0,
					 0, 0, 0, 1);*/
					
					// EVEN IF YOU ARE NOT WORKING ON THE SECOND ITERATION,
					// YOU MUST APPLY THE MODEL VIEW AND PROJECTION
					// MATRICES TO vertexPosition TO GET gl_Position!*/
					gl_Position = projection_persp * M * trans * vertexPosition; 
					fragmentColor = vertexColor;
				}

		</script>

	<script id="fragment-shaderChair2" type="x-shader/x-fragment">
			precision mediump float;
			
			//varying vec4 fColor; //**normal coloring before shading

			// INSERT CODE HERE
			// Step 3.3: Lighting Calculations in Fragment Shader
			
			// If you are doing Gouraud shading, you will require a varying variable
			// for the final light intensity (and you can disregard the comment below)
			varying vec3 R;
			
			
			// If you are doing Phong shading, you will need varying variables for
			// the light components when they come to the vertex position (for point
			// and spot light, the light gets attenuated),
			// and varying variables to interpolate the vector against the incident direction (i), the
			// view vector (view), and the normal vector (n)
			// (If you are doing Phong, disregard the comment above)
			
			void main() {
			
				//gl_FragColor = fColor; //**
				
				// If you are doing Gouraud shading, you can disregard
				// all the lines from "Start of Phong shading" to
				// "End of Phong shading" and jump directly to the end
				// of this function
				
				// *** Start of Phong shading ***
				
				// Normalize the varying variables that should be unit
				// vectors (i, view, and n)
				
				
				
				// Compute the ambient reflection for the first light source
				// using the interpolated lighting components
				
				
				
				// Compute the diffuse reflection for the first light source
				// using the interpolated lighting components,
				// and normalized i and n
				
				
				
				// Compute the specular reflection for the first light source
				// using the interpolated lighting components,
				// and normalized i, n, and v
				
				
				
				
				// Compute the ambient reflection for the second light source
				// using the interpolated lighting components
				
				
				
				// Compute the diffuse reflection for the second light source
				// using the interpolated lighting components,
				// and normalized i and n
				
				
				
				// Compute the specular reflection for the second light source
				// using the interpolated lighting components,
				// and normalized i, n, and v
				
				
				
				
				// Calculate the total reflected light by summing
				// the ambient, diffuse, and specular reflections for
				// all lights that are on. With Phong shading,
				// off lights should have their components
				// zeroed out in the vertex shader. This reflected
				// light represents the final light intensity
				
				
				// *** End of Phong shading ***
				
				
				// when you are done with lighting calculations,
				// change the code below to assign the final light
				// intensity to gl_FragColor
				gl_FragColor = vec4( R.r, R.g, R.b, 1.0 );
			}

		</script>

	<script id="fragment-shader" type="x-shader/x-fragment">
			precision mediump float;
			
			//varying vec4 fColor; //**normal coloring before shading

			// INSERT CODE HERE
			// Step 3.3: Lighting Calculations in Fragment Shader
			
			// If you are doing Gouraud shading, you will require a varying variable
			// for the final light intensity (and you can disregard the comment below)
			varying vec3 R;
			
			
			// If you are doing Phong shading, you will need varying variables for
			// the light components when they come to the vertex position (for point
			// and spot light, the light gets attenuated),
			// and varying variables to interpolate the vector against the incident direction (i), the
			// view vector (view), and the normal vector (n)
			// (If you are doing Phong, disregard the comment above)
			
			void main() {
			
				//gl_FragColor = fColor; //**
				
				// If you are doing Gouraud shading, you can disregard
				// all the lines from "Start of Phong shading" to
				// "End of Phong shading" and jump directly to the end
				// of this function
				
				// *** Start of Phong shading ***
				
				// Normalize the varying variables that should be unit
				// vectors (i, view, and n)
				
				
				
				// Compute the ambient reflection for the first light source
				// using the interpolated lighting components
				
				
				
				// Compute the diffuse reflection for the first light source
				// using the interpolated lighting components,
				// and normalized i and n
				
				
				
				// Compute the specular reflection for the first light source
				// using the interpolated lighting components,
				// and normalized i, n, and v
				
				
				
				
				// Compute the ambient reflection for the second light source
				// using the interpolated lighting components
				
				
				
				// Compute the diffuse reflection for the second light source
				// using the interpolated lighting components,
				// and normalized i and n
				
				
				
				// Compute the specular reflection for the second light source
				// using the interpolated lighting components,
				// and normalized i, n, and v
				
				
				
				
				// Calculate the total reflected light by summing
				// the ambient, diffuse, and specular reflections for
				// all lights that are on. With Phong shading,
				// off lights should have their components
				// zeroed out in the vertex shader. This reflected
				// light represents the final light intensity
				
				
				// *** End of Phong shading ***
				
				
				// when you are done with lighting calculations,
				// change the code below to assign the final light
				// intensity to gl_FragColor
				gl_FragColor = vec4( R.r, R.g, R.b, 1.0 );
			}

		</script>
		
		<script id="fragment-shaderTable" type="x-shader/x-fragment">
			precision mediump float;
			varying vec4 fragmentColor;
			
			void main() {
				gl_FragColor = fragmentColor;
			}

		</script>

	<script type="text/javascript" src="../Common/webgl-utils.js"></script>
	<script type="text/javascript" src="../Common/initShaders.js"></script>
	<script type="text/javascript" src="../Common/MV.js"></script>

	<script type="text/javascript" src="./object.js"></script>

	<script type="text/javascript" src="./WebGL3D/params/ControlParams.js"></script>
	<script type="text/javascript" src="./WebGL3D/params/TextureParams.js"></script>
	<script type="text/javascript" src="./WebGL3D/params/ObjectParams.js"></script>
	<script type="text/javascript" src="./WebGL3D/params/ProjectionParams.js"></script>
	<script type="text/javascript" src="./WebGL3D/params/LightingParams.js"></script>

	<script type="text/javascript" src="./WebGL3D/WebGLCamera.js"></script>
	<script type="text/javascript" src="./WebGL3D/WebGLLight.js"></script>
	<script type="text/javascript" src="./WebGL3D/WebGL3DObject.js"></script>

	<script type="text/javascript" src="./project2.js"></script>
</head>

<body onload="initGL()">
	<canvas id="gl-canvas" height="512" width="512"></canvas>
</body>

</html>